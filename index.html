<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Space Empire â€“ Galaxy Prototype</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: Arial, sans-serif;
    color: white;
  }
  canvas {
    display: block;
  }
  .hud {
    position: fixed;
    top: 10px;
    left: 10px;
    font-size: 14px;
    line-height: 1.4em;
    user-select: none;
  }
</style>
</head>
<body>

<div class="hud">
  ðŸŒŒ Galaxy View<br>
  ðŸŸ¢ Green = Your Fleet<br>
  âšª White = Stars<br>
  Click = preview order<br>
  Click again = confirm<br>
  ESC = cancel order<br>
  Drag = Pan | Wheel = Zoom<br>
  SPACE = Pause
</div>

<canvas id="game"></canvas>

<script>
/* =======================
   CANVAS & CAMERA
======================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

const camera = {
  x: 0,
  y: 0,
  zoom: 1
};

/* =======================
   GLOBAL SIM STATE
======================= */
const Simulation = {
  paused: false
};

/* =======================
   WORLD OBJECTS
======================= */
const stars = [];
for (let i = 0; i < 60; i++) {
  stars.push({
    x: (Math.random() - 0.5) * 4000,
    y: (Math.random() - 0.5) * 4000
  });
}

const FleetState = {
  IDLE: "IDLE",
  MOVING: "MOVING",
  ARRIVED: "ARRIVED"
};

const fleet = {
  x: 0,
  y: 0,
  speed: 2,
  target: null,
  state: FleetState.IDLE
};

/* =======================
   INPUT STATE
======================= */
let isDragging = false;
let lastMouse = { x: 0, y: 0 };
let previewTarget = null;

/* =======================
   INPUT HANDLERS
======================= */
canvas.addEventListener("mousedown", e => {
  isDragging = true;
  lastMouse.x = e.clientX;
  lastMouse.y = e.clientY;
});

canvas.addEventListener("mousemove", e => {
  if (!isDragging) return;
  const dx = e.clientX - lastMouse.x;
  const dy = e.clientY - lastMouse.y;
  camera.x -= dx / camera.zoom;
  camera.y -= dy / camera.zoom;
  lastMouse.x = e.clientX;
  lastMouse.y = e.clientY;
});

canvas.addEventListener("mouseup", () => {
  isDragging = false;
});

canvas.addEventListener("wheel", e => {
  const zoomAmount = e.deltaY * -0.001;
  camera.zoom = Math.min(3, Math.max(0.3, camera.zoom + zoomAmount));
});

canvas.addEventListener("click", e => {
  const world = screenToWorld(e.clientX, e.clientY);

  if (!previewTarget) {
    previewTarget = world;
  } else {
    fleet.target = previewTarget;
    fleet.state = FleetState.MOVING;
    previewTarget = null;
  }
});

window.addEventListener("keydown", e => {
  if (e.code === "Escape") {
    previewTarget = null;
  }
  if (e.code === "Space") {
    Simulation.paused = !Simulation.paused;
  }
});

/* =======================
   COORD TRANSFORMS
======================= */
function worldToScreen(x, y) {
  return {
    x: (x - camera.x) * camera.zoom + canvas.width / 2,
    y: (y - camera.y) * camera.zoom + canvas.height / 2
  };
}

function screenToWorld(x, y) {
  return {
    x: (x - canvas.width / 2) / camera.zoom + camera.x,
    y: (y - canvas.height / 2) / camera.zoom + camera.y
  };
}

/* =======================
   UPDATE LOGIC
======================= */
function updateFleet() {
  if (Simulation.paused) return;
  if (fleet.state !== FleetState.MOVING || !fleet.target) return;

  const dx = fleet.target.x - fleet.x;
  const dy = fleet.target.y - fleet.y;
  const dist = Math.hypot(dx, dy);

  if (dist <= fleet.speed) {
    fleet.x = fleet.target.x;
    fleet.y = fleet.target.y;
    fleet.target = null;
    fleet.state = FleetState.ARRIVED;
    return;
  }

  fleet.x += (dx / dist) * fleet.speed;
  fleet.y += (dy / dist) * fleet.speed;
}

/* =======================
   RENDER
======================= */
function draw() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.translate(canvas.width / 2, canvas.height / 2);
  ctx.scale(camera.zoom, camera.zoom);
  ctx.translate(-camera.x, -camera.y);

  // Stars
  ctx.fillStyle = "white";
  stars.forEach(s => {
    ctx.beginPath();
    ctx.arc(s.x, s.y, 4, 0, Math.PI * 2);
    ctx.fill();
  });

  // Preview order
  if (previewTarget) {
    ctx.strokeStyle = "red";
    ctx.setLineDash([10, 6]);
    ctx.beginPath();
    ctx.moveTo(fleet.x, fleet.y);
    ctx.lineTo(previewTarget.x, previewTarget.y);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = "red";
    ctx.beginPath();
    ctx.arc(previewTarget.x, previewTarget.y, 6, 0, Math.PI * 2);
    ctx.fill();
  }

  // Fleet
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(fleet.x, fleet.y, 8, 0, Math.PI * 2);
  ctx.fill();

  ctx.fillStyle = "lime";
  ctx.fillText("Your Fleet (" + fleet.state + ")", fleet.x + 12, fleet.y - 12);
}

/* =======================
   LOOP
======================= */
function loop() {
  updateFleet();
  if (fleet.state === FleetState.ARRIVED) {
    fleet.state = FleetState.IDLE;
  }
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>

</body>
</html>
