<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ================= CAMERA ================= */
const camera = {
  x: 0,
  y: 0,
  zoom: 1
};

/* ================= STATE ================= */
let paused = false;
let dragging = false;
let lastMouse = { x: 0, y: 0 };

/* ================= FLEET ================= */
const fleet = {
  x: 0,
  y: 0,
  tx: null,
  ty: null,
  speed: 80,
  state: "IDLE",
  eta: 0
};

/* ================= STARS ================= */
const stars = [];
for (let i = 0; i < 100; i++) {
  stars.push({
    x: (Math.random() - 0.5) * 4000,
    y: (Math.random() - 0.5) * 4000
  });
}

/* ================= HELPERS ================= */
function screenToWorld(x, y) {
  return {
    x: (x - canvas.width / 2) / camera.zoom + camera.x,
    y: (y - canvas.height / 2) / camera.zoom + camera.y
  };
}

/* ================= INPUT ================= */
canvas.addEventListener("mousedown", e => {
  dragging = true;
  lastMouse.x = e.clientX;
  lastMouse.y = e.clientY;
});

window.addEventListener("mouseup", () => dragging = false);

canvas.addEventListener("mousemove", e => {
  if (!dragging) return;
  const dx = (e.clientX - lastMouse.x) / camera.zoom;
  const dy = (e.clientY - lastMouse.y) / camera.zoom;
  camera.x -= dx;
  camera.y -= dy;
  lastMouse.x = e.clientX;
  lastMouse.y = e.clientY;
});

/* ================= ZOOM (FIXED) ================= */
canvas.addEventListener("wheel", e => {
  e.preventDefault();

  const mouseWorldBefore = screenToWorld(e.clientX, e.clientY);

  const zoomFactor = Math.exp(-e.deltaY * 0.001);
  camera.zoom = Math.min(5, Math.max(0.2, camera.zoom * zoomFactor));

  const mouseWorldAfter = screenToWorld(e.clientX, e.clientY);

  camera.x += mouseWorldBefore.x - mouseWorldAfter.x;
  camera.y += mouseWorldBefore.y - mouseWorldAfter.y;
}, { passive: false });

/* ================= CLICK MOVE ================= */
canvas.addEventListener("click", e => {
  const w = screenToWorld(e.clientX, e.clientY);
  fleet.tx = w.x;
  fleet.ty = w.y;
  fleet.state = "MOVING";
});

/* ================= KEYBOARD ================= */
window.addEventListener("keydown", e => {
  if (e.code === "Space") paused = !paused;
});

/* ================= UPDATE ================= */
function update(dt) {
  if (paused) return;

  if (fleet.state === "MOVING") {
    const dx = fleet.tx - fleet.x;
    const dy = fleet.ty - fleet.y;
    const d = Math.hypot(dx, dy);

    if (d < 1) {
      fleet.x = fleet.tx;
      fleet.y = fleet.ty;
      fleet.state = "IDLE";
    } else {
      const step = fleet.speed * dt;
      fleet.x += dx / d * step;
      fleet.y += dy / d * step;
      fleet.eta = (d / fleet.speed).toFixed(1);
    }
  }
}

/* ================= DRAW ================= */
function draw() {
  ctx.setTransform(
    camera.zoom, 0, 0, camera.zoom,
    canvas.width / 2 - camera.x * camera.zoom,
    canvas.height / 2 - camera.y * camera.zoom
  );

  ctx.fillStyle = "black";
  ctx.fillRect(camera.x - 5000, camera.y - 5000, 10000, 10000);

  // stars
  ctx.fillStyle = "white";
  stars.forEach(s => {
    ctx.beginPath();
    ctx.arc(s.x, s.y, 2 / camera.zoom, 0, Math.PI * 2);
    ctx.fill();
  });

  // fleet
  ctx.fillStyle = "lime";
  ctx.beginPath();
  ctx.arc(fleet.x, fleet.y, 6 / camera.zoom, 0, Math.PI * 2);
  ctx.fill();

  ctx.resetTransform();

  // HUD label
  if (fleet.state === "MOVING") {
    ctx.fillStyle = "lime";
    ctx.fillText(`MOVING (${fleet.eta}s)`,
      canvas.width / 2 + (fleet.x - camera.x) * camera.zoom + 8,
      canvas.height / 2 + (fleet.y - camera.y) * camera.zoom - 8
    );
  }
}

/* ================= LOOP ================= */
let last = performance.now();
function loop(t) {
  const dt = (t - last) / 1000;
  last = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
loop(last);
</script>
